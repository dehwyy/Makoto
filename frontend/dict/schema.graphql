"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

input ChangePasswordByAnswerInput {
  answer: String!
  new_password: String!
}

input ChangePasswordInput {
  new_password: String!
  old_password: String!
}

input EditWordInput {
  word: Word!
  wordId: ID!
}

input GetUserByIdInput {
  userId: ID!
}

input GetUserByUsernameInput {
  username: String!
}

type GetWordsResponse {
  tokens: Tokens
  words: [WordWithId!]!
}

type Mutation {
  EditWord(input: EditWordInput): Tokens
  RemoveWord(wordId: ID!): Tokens
  changePassword(input: ChangePasswordInput!): UserAuthResponse!
  changePasswordByAnswer(input: ChangePasswordByAnswerInput!): UserAuthResponse!
  createWord(word: Word!): Tokens
  signIn(input: SignInInput!): UserAuthResponse!
  signOut: Status!
  signUp(input: SignUpInput!): UserAuthResponse!
}

type Query {
  getQuestion: UserQuestionResponse!
  getUserById(input: GetUserByIdInput!): UserResponse!
  getUserByUsername(input: GetUserByUsernameInput!): UserResponse!
  getWords(userId: ID): GetWordsResponse!
}

input SignInInput {
  password: String!
  username: String!
}

input SignUpInput {
  answer: String!
  password: String!
  question: String!
  username: String!
}

type Status {
  is_ok: Boolean!
}

type Tag {
  tagId: ID!
  text: String!
}

type Tokens {
  access_token: String!
  refresh_token: String!
}

type UserAuthResponse {
  tokens: Tokens!
  userId: ID!
}

type UserQuestionResponse {
  auth: UserAuthResponse!
  question: String!
}

type UserResponse {
  auth: UserAuthResponse!
  username: String!
}

input Word {
  extra: String!
  tags: [String!]!
  value: String!
  word: String!
}

type WordWithId {
  extra: String!
  tags: [Tag!]!
  value: String!
  word: String!
  wordId: ID!
}
